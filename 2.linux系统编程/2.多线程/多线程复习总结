一.多线程 常用在IO密集型操作即读写操作较多的，比如爬虫 
    threading中的Thread创建子线程，然后通过start开启，另一种方式为写个类继承这个Thread，实现run方法，实例化该类start启动。主线程等待子线程结束才结束。
    线程特点
    全局变量共用，但局部变量各个线程是各个线程的
二.0号进程和1号进程
    0号进程：系统创建的第一个进程，完成加载系统后，演变为进程调度
    1号进程：由0号进程创建，完成系统的初始化，是系统中所有其他进程的祖先进程，linux中所有进程都是由它创建并运行的，在系统启动完成后，变为守护进程监视其他系统进程
三.僵尸进程和孤儿进程
    僵尸进程：进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中的这些进程是僵尸进程
    孤儿进程：父进程先于子进程退出，这时子进程还未结束，此时的子进程称为孤儿进程，孤儿进程将被1号进程收养处理。所以孤儿进程实际上是不占用资源的。
    避免僵尸进程的方法：1.fork两次用孙子进程去完成子进程的任务
    2.用wait函数使父进程阻塞
    3.使用信号量，在signal handler中调用waitpid，这样父进程不用阻塞
四.互斥锁
    threading中的Lock，进行实例化后返回一把锁，该锁默认为开着的，需要用acquire进行锁定，另一个线程里的acquire则被阻塞，直到该锁release释放后，进行抢着上锁。
    互斥锁是通知不是轮询
    对全局变量修改时才加，不修改时不加
五.避免死锁
    死锁：在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。
    1.添加超时时间
    2.程序设计时尽量避免死锁（银行家算法）
六.同步与异步，阻塞与非阻塞
    http://baijiahao.baidu.com/s?id=1604983471279587214&wfr=spider&for=pc
七.threading中的local
    解决多线程中全局变量各个线程是各个线程的，不共享的问题，实例化local()对象，为其添加一个属性，各个线程是各个线程的。
八.线程是并发，进程是并行。
九.GIL：全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行。