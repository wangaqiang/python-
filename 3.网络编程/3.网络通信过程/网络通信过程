一.网络通信过程
    发送方：应用层发出数据——>传输层给数据加上目的端口和源端口号——>网络层加上目的IP和源IP——>链路层加上MAC地址————>接受方链路层拆包看MAC地址是否一样——>网络层看IP地址——>传输层看端口号决定给应用层哪个进程——>应用层相应的进程收到数据。
二.组网
    DHCP：自动分配IP地址 statc：手动分配

三.交换机
    作用：可以链接多台电脑，第一次是广播，后面变成了单播
四.MAC地址即网卡的序列号
    六个字节的十六进制，前三个字节是厂商，后三个是该厂商生产的，每个MAC地址都不一样。
    只收两个：一个是自己的MAC地址，一个是全为F的MAC地址即广播地址 它把收到的包给IP还是ARP根据类型判断，如果是0x806则传给ARP，0x800则给IP
五.ICMP和ARP
    ICMP：ping一个电脑
    ARP：获取一个电脑的MAC地址，根据IP地址找MAC地址 arp -a 查看缓存列表  存在一定时间  arp -d 清除缓存 
    RARP：根据MAC地址找IP地址
六.路由器
    作用：链接不同的网络使能够通信，因为他有两个网卡.
    工作在第三层即网络层，所以路由器之间传递数据包时，根据路由表转发。
    https://blog.csdn.net/tham_/article/details/42060511
    上面是详细的帖子
    MAC地址两个设备之间通信时在变化  实际转发时设备的地址
    IP地址两个设备之间通信时不变化 标记逻辑上的地址
    NETMASK：和ip地址一起确定网络号
    默认网关：发送的IP不在一个网段内，会默认转发给网关
七.DNS协议：解析域名所用udp包
八.DHCP协议：自动分配IP地址
九.访问百度的过程：
    1.解析域名对应的IP地址
        1.使用ARP获取默认网关的MAC地址
        2.组织数据发送给默认网关(IP是DNS服务器的IP，MAC地址是默认网关的MAC地址)
        3.默认网关有转发数据的能力，把数据转发给路由器
        4.路由器根据自己的路由协议，选择一个合适的路径，转发数据到目的网关
        5.目的网关(DNS服务器所在的网关),把数据转发给DNS服务器
        6.DNS服务器查询解析出域名对应的IP地址,并原路返回给请求这个域名的客户端
    2.得到了IP后,先发送TCP进行三次握手链接
    3.使用HTTP协议发送请求数据给服务器
    4.服务器收到请求之后将数据传给客户端
    5.浏览器收到数据后进行渲染
    6.浏览器关闭tcp链接,即四次挥手
十.TCP三次握手和四次挥手
    三次握手:客户端调用connect时先发一个SYN包,
        服务器回复一个SYN+ACK包,
        客户端发送一个ACK包
    双方发包对方都会回复一个ACK包
    四次挥手:假如客户端先调用close先发FIN包,
        然后服务器回复ACK确认包,
        然后服务器调用close发送FIN包,
        客户端回复ACK包为四次挥手
十一.长连接和短连接 
    一次链接,直到所有数据发送完才断开链接,如lol,在线播放视频等
    发个消息断开链接直到下次要发数据时,如获取一个网页
十二.TCP的十种状态
    LISTEN,SYN_SEND,SYN_RECV,ESTABLISHED,FIN_WAIT1,CLOSE_WAIT,FIN_WAIT2,LAST_WAIT,TIME_WAIT,CLOSE
    三次握手:1.客户端在发送SYN包后变为SYN_SEND状态,而服务器接受到包由之前的LISTEN状态变为SYN_RECV状态
            2.服务器向客户端发送SYN包加ACK包后,变为ESTABLISHED状态
            3.客户端收到SYN+ACK包后,回复ACK包后变为ESATABLISHED
    四次挥手:1.客户端调用close发送FIN包后由之前的ESTABLISHED变为FIN_WAIT1
            2.服务器收到FIN包后变为CLOSE_WAIT状态
            3.服务器发送ACK包,客户端收到ACK包后由FIN_WAIT1变为FIN_WAIT2状态
            4.服务器调用close发送FIN包,由CLOSE_WAIT变为LAST_WAIT状态
            5.客户端收到FIN包后并发送ACK包由FIN_WAIT2变为TIME_WAIT状态
            6.服务端收到ACK包后,由LAST_WAIT状态变为CLOSE
            7.客户端发送ACK包后,经过2MSL时间,由TIME_WAIT状态变为CLOSE状态.
十三.2MSL问题即数据包最长存活时间
    PING时TTL代表经过的路由最大值,同一个网段128,经过一次减去1,减到0则路由器把包扔掉
    服务器发过FIN包后,客户端要发送最后一次ACK包,一个包在网络存在时间即MSL为1-2分钟,客户端发送过去后,如果发送失败即服务端没收到ACK包时,服务器会认为客户端没收到FIN包进行重新发送FIN包
    所以客户端发送ACK包后需要等待自己包过去的MSL时间,在假设服务端没收到时给自己重发FIN包的MSL时间,即总共2MSL时间,如果2MSL期间没收到服务端发送的FIN包,说明自己刚发送的ACK包已经到达服务端完成四次挥手
    这也是Ctrl+c结束TCP服务端后重启程序失败的原因,因为这样相当于服务端调用close所以最后服务端要等待2MSL时间,在这期间服务端保留这信息,所以不能.
    解决:setsockopt(SOL_SOCKET,SO_REUSEADDR,1)用这句话即可重复绑定
十四.listen()参数问题
    里面的参数是半链接和已链接总和
十五.常见网络攻击
    1.tcp半链接攻击 (DDOS攻击,SYN洪水攻击)
    2.dns攻击
    3.arp攻击